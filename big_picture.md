# Broad Picture

- API costs get very high when using coding agents in large software construction projects because the context window gets very large. Also, as the context window get larger, the AI degrades in performance. This is why entire software construction projects cannot be completed in one prompt.
- Solution: Utilize chain of LLM ideas and a hierarchical structure mirroring a GitHub repository to split large software construction tasks into smaller easier-to-complete tasks.
- How: each folder and file will get its own agent, that is only active when called upon by its parent. Folders will have manager agents and files will have coder agents. We will use a hierarchical structure, where parent agents can decide which of their children become active by prompting them with a task. Agents will “forget” everything upon completion of their task, and report what they did back to their parent, who can review their work. All agents will maintain a readme for future iterations of itself to use as a guide. It this manner, we can keep context windows small but filled with enough information for the job to be finished, saving API costs.
- Manager agents will have the ability to create and delete files inside of their folder. They will be able to Delegate tasks to their children. The delegation process will be set up so that a manager will be able to delegate many tasks at once, which will all run concurrently, if the manager decides the tasks are not interdependent. Therefore, the manager will also have a wait command, which they can use when one of their children finishes their task but another hasn’t. In this case, they will also be able to re-task the returning child instead of waiting, as well, or do another action. If codes are interdependent, the manager agent can decide to do them one by one by simply delegating one at a time.
- All agents will be able to read all codes in the code base if they deem necessary, and the entire codebase structure will be part of every prompt. All agents will also be able to run terminal commands, although this should be relatively limited, maybe to just running tests.
- A main goal of this project, in order to keep context windows small, is that agents will produce interfaces (the initial language we will apply this to is typescript), and then there will be separate files with implementations. This way, readers only have to read the interface, where the spec, contract of each function, preconditions, postconditions, etc exist so that other agents can use those functions with out having to process thousands of lines of the actual implementation. Also, it enables more concurrent development, because other agents can use the functions before they have been implementing, knowing that they will be implemented eventually.
- Coder agents will automatically read their own code in their first prompt, and have the ability to read any other codes and modify their own code.
- Test first programming will be ingrained into the agents, mirroring how it is actually done in real life. This can be pictured as a project starting as a wave of prompts going down the src side for agents to spec their ADTs, then the wave returns to the top after specs are done, and the wave travels to the test side of the repository, where agents partition and then build their test suites based on the specs. Then, the wave travels back up the agent tree, and then back down the src side, where agents can begin implementation, using the tests along the way. The agents will continue waving up and down the tree until the entire project is finished.
- There will exist a documentation folder, which is filled with necessary readings, files, libraries, etc by the human, which models will be able to access. Managers will inform children which of these documentations will be necessary for their task.